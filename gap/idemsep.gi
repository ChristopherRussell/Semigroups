###############################################################################
# Idempotent separating congruences
###############################################################################
InstallMethod(IsIdempotentSeparatingCongruence,
"for an inverse semigroup congruence by kernel trace",
[IsInverseSemigroupCongruenceByKernelTrace],
function(cong)
  return ForAll(TraceOfSemigroupCongruence(cong), a -> Size(a) = 1);
end);

# # General method
# InstallMethod(IsIdempotentSeparatingCongruence,
# "for a semigroup congruence",
# [IsSemigroupCongruence],
# function(cong)
#
# end);

# TODO: do we need a check that <N> can be a kernel? Or can we leave this check
# to the InverseSemigroupCongruenceByKernelTrace method?
InstallMethod(InverseSemigroupIdempotentSeparatingCongruence,
"for an inverse semigroup and an inverse subsemigroup",
[IsInverseSemigroup, IsInverseSemigroup],
function(S, N)
  return InverseSemigroupCongruenceByKernelTrace(
    S, N, List(Idempotents(S), e -> [e]));
end);

###############################################################################
# Finding the maximum idempotent separating congruence
###############################################################################
InstallMethod(MaximumIdempotentSeparatingCongruence,
"for an inverse semigroup", [IsInverseSemigroup],
function(S)
  return InverseSemigroupIdempotentSeparatingCongruence(S,
    SEMIGROUPS.KernelMaxIdempotentSeparatingCongruence(S));
end);

# The max idempotent separating congruence is defined via it's kernel AKA the
# centralizer of the semilattice of idempotents
#
# TODO: Follow the "calculate as little as possible" philosophy by calculating
# less until the point it is wanted by the user.
# TODO: Should these be a new type of object, separate from other congruences?
# TODO: Basic method for non-inverse semigroups?

SEMIGROUPS.KernelMaxIdempotentSeparatingCongruence := function(S)
  local po, top, Hgroups, out_gens, G, stab, e, f, iso, reps, i, D, H, rep;
  po := DigraphReflexiveTransitiveReduction(
          Digraph(PartialOrderOfDClasses(S)));

  # top is an sequence to move up the partial order of D-classes
  top := DigraphTopologicalSort(po);
  Hgroups := List(DClasses(S), D -> HClasses(D));
  Apply(Hgroups, D -> Filtered(D, IsGroupHClass));

  # out_gens will store the generators of a group H-class from each D-class of
  # the maximimum idempotent separating congruence's Kernel
  out_gens := EmptyPlist(Size(Hgroups));
  # Add the generators of the minimal H-class (which is also a D-class)
  out_gens[top[1]] := ShallowCopy(GeneratorsOfInverseSemigroup(
                        InverseSemigroup(Hgroups[top[1]][1])));
  for i in [2 .. Length(top)] do
    # we choose a representative group H-class of this D-class and find the
    # elements which commute with all idempotents of all D-classes immediately
    # below this one.
    G := Hgroups[top[i]][1];
    stab := ShallowCopy(Elements(G));
    for D in OutNeighboursOfVertex(po, top[i]) do
      e := MultiplicativeNeutralElement(G);

      if Size(Hgroups[D]) = 1 then
        H := Hgroups[D][1];
        f := MultiplicativeNeutralElement(Hgroups[D][1]);
        stab := Filtered(stab, g -> g * f in H);
      else
        for H in Hgroups[D] do
          f := MultiplicativeNeutralElement(H);
          if e * f = f then
            stab := Filtered(stab, g -> g * f in H);

            # finding the core is equivalent to looping through all group
            # H-classes of this D class and intersecting the stab's
            iso := IsomorphismPermGroup(G);
            stab := Core(Image(iso), Group(List(stab, s -> s ^ iso)));
            stab := List(Elements(stab), g -> g / iso);
          fi;
        od;
      fi;
    od;

    # we now find generators of the subgroup generated by stab and map them to
    # the other group H-classes of the current D-class via isomorphisms.
    out_gens[top[i]] := [];
    stab := ShallowCopy(GeneratorsOfInverseSemigroup(InverseSemigroup(stab)));
    reps := HClassReps(RClassOfHClass(Hgroups[top[i]][1]));
    for rep in reps do
      Append(out_gens[top[i]], List(stab, g -> rep ^ -1 * g * rep));
    od;
  od;

  out_gens := Concatenation(out_gens);
  return InverseSemigroup(out_gens);
end;

###############################################################################
# Idempotent separating congruences by generator
###############################################################################
# Does not always exist but when it does it is contained in the Kernel of the
# maximum idempotent separating congruence AKA the centralizer of idempotents.

# NOT WORKING: Need to take the (group) normal closure in every H-class, not
# just the top one!
# TODO: Turn this into a method which takes an arbitrary number of pairs
# TODO: is this method necessary?
# I think that the idempotent separating congruences form an order ideal so
# the existing methods should also be able to return the idempotent separating
# congruences without any modification.
SEMIGROUPS.KernelIdempotentSeparatingCongruenceByGeneratingPair
  := function(S, pair)
  local s, t, x, H, iso, N, gens_N, E_S, out_gens, reps, e, rep;
  s := pair[1];
  t := pair[2];
  x := s ^ -1 * t;
  H := GreensHClassOfElement(S, x);

  # If x is not in a group H class then it cannot be in the kernel of an
  # idempotent separating homomorphism.
  if not IsGroupHClass(H) then
    return fail;
  fi;

  # If x is in the kernel of an idempotent separating homomorphism then it's
  # normal closure in it's group H class must also be in the kernel.
  iso := IsomorphismPermGroup(InverseSemigroup(H));
  N := NormalClosure(Image(iso), Subgroup(Image(iso), [x ^ iso]));
  gens_N := List(GeneratorsOfGroup(N), g -> g / iso);
  E_S := IdempotentGeneratedSubsemigroup(S);

  # The restriction of N to lower D classes must be
  for e in InverseSemigroupOrderIdeal(E_S, [x * x ^ -1]) do
    if not ForAll(gens_N, g -> e * g in HClass(S, e)) then
      return fail;
    fi;
  od;

  out_gens := [];

  reps := HClassReps(RClassOfHClass(H));
  for rep in reps do
    Append(out_gens, List(gens_N, g -> rep ^ -1 * g * rep));
  od;

  return InverseSemigroup(E_S, out_gens);
end;

SEMIGROUPS.KerIdSepCongByGeneratingPair := function(S, pair)
  return
    SEMIGROUPS.KernelIdempotentSeparatingCongruenceByGeneratingPair(S, pair);
end;

# Turn this into a method which takes an arbitrary number of pairs
IdempotentSeparatingCongruenceByGeneratingPair := function(S, pair)
  return InverseSemigroupIdempotentSeparatingCongruence(S,
    SEMIGROUPS.KerIdSepCongByGeneratingPair(S, pair));
end;

###############################################################################
# Lattice of congruences
###############################################################################
# TODO: Avoid finding congruences for all pairs in N \ E(S).
InstallMethod(LatticeOfIdempotentSeparatingCongruences,
"for an inverse semigroup",
[IsInverseSemigroup],
function(S)
  local N, E_S, congs, cong, pairs, latt, s;
  N := SEMIGROUPS.KernelMaxIdempotentSeparatingCongruence(S);
  E_S := IdempotentGeneratedSubsemigroup(S);
  congs := [];
  for s in Difference(N, IdempotentGeneratedSubsemigroup(S)) do
    cong := SemigroupCongruence(S, [s, s * s ^ -1]);
    if not cong in congs then
      Add(congs, cong);
    fi;
  od;
  pairs := List(GeneratorsOfSemigroup(S), x -> [x, x * x ^ -1]);
  Add(congs, SemigroupCongruence(S, pairs));
  latt := JoinSemilatticeOfCongruences(congs, JoinSemigroupCongruences);
  return latt;
end);

###############################################################################
# (Bad) methods relating to normal semigroups
###############################################################################
IsNormalInverseSubsemigroup := function(S, N)
  return ForAll(Elements(S), s -> ForAll(Elements(N), n -> s ^ -1 *
  n * s in Elements(N)));
end;

# Assumes N contains all idempotents of S.
NormalInverseClosure := function(S, N)
  local out, s, n;
  out := ShallowCopy(Elements(N));
  for s in Semigroup(S) do
    for n in N do
      if not IsIdempotent(n) then
        AddSet(out, s ^ -1 * n * s);
      fi;
    od;
  od;
  return InverseSemigroup(out);
end;

# This following method does not work in general. See
#InverseMonoid(
#[ PartialPerm([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 3, 4, 5, 1, 7, 8, 9,
#  10, 6]),
#  PartialPerm([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 1, 3, 4, 5, 7, 6, 8, 9,
#  10]),
#  PartialPerm([2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 10, 6, 7, 8, 9]),
#  PartialPerm([1, 2, 3, 4, 6, 7, 8, 9, 10], [2, 3, 4, 5, 7, 8, 9, 10, 6])])
# and the normal subsemigroup generated by
# PartialPerm( [ 6, 7, 8, 9, 10 ], [ 6, 7, 8, 10, 9 ] )

# NormalInverseClosure := function(S, N)
#   local out, s, n;
#   out := ShallowCopy(N);
#   for s in GeneratorsOfInverseSemigroup(S) do
#     for n in N do
#       if not (IsIdempotent(n) or IsIdempotent(s)) then
#         AddSet(out, s ^ -1 * n * s);
#       fi;
#     od;
#   od;
#   return InverseSemigroup(out);
# end;

###############################################################################
# Order ideal methods
###############################################################################

_OrderIdeal := function(po, gens)
  local out, func, i;
  out := Set(gens);

  func := function(p)
    local j;
    for j in po[p] do
      if not j in out then
        func(j);
        Add(out, j);
      fi;
    od;
  end;

  for i in gens do
    func(i);
  od;

  return out;
end;

InstallMethod(InverseSemigroupOrderIdeal,
"for an inverse semigroup and a list",
[IsInverseSemigroup, IsList],
function(S, subset)
  local po, el, pos;
  po := NaturalPartialOrder(S);
  el := Elements(S);
  pos := List(subset, s -> Position(el, s));
  return Set(_OrderIdeal(po, pos), a -> el[a]);
end);

InverseSemigroupOrderIdeals := function(S)
  local n, po, gr, principal, ins, out, ideal, next, bt, i;
  n := Size(S);
  po := NaturalPartialOrder(S);
  principal := [];
  for i in [1 .. n] do
    Add(principal, Union(po[i], [i]));
  od;
  gr := DigraphTransitiveReduction(Digraph(po));
  ins := InNeighbours(gr);
  out := [];
  ideal := [];
  next := Filtered([1 .. n], i -> IsEmpty(po[i]));

  bt := function(A, ext)
    local B, new, k;
    for k in [1 .. Size(ext)] do
      B := Union(A, principal[ext[k]]);
      if not B in out then
        new := DifferenceLists(ext, B);
        new := Concatenation(new, ins[ext[k]]);
        AddSet(out, B);
        bt(B, new);
      fi;
    od;
  end;

  bt(ideal, next);
  return out;
end;

_InverseSemigroupOrderIdeals := function(S, super, is_full)
  local n, po, principal, gr, ins, out, ideal, next, bt, i;
  n := Size(S);
  po := NaturalPartialOrder(S);
  principal := [];
  for i in [1 .. n] do
    Add(principal, Union(po[i], [i]));
  od;
  gr := DigraphTransitiveReduction(Digraph(po));
  ins := InNeighbours(gr);
  out := [];
  if is_full then
    ideal := List(Idempotents(S), s -> Position(Elements(S), s));
  else
    ideal := [];
  fi;
  next := Filtered([1 .. n], i -> IsEmpty(po[i]) and not i in ideal);
  if IsEmpty(next) then
    next := Filtered(ins[Position(Elements(S), MultiplicativeZero(S))], i -> not
            i in ideal);
  fi;

  bt := function(A, ext)
    local B, new, k;
    for k in [1 .. Size(ext)] do
      B := Union(A, principal[ext[k]]);
      if IsSubset(super, B) and not B in out then
        new := DifferenceLists(ext, B);
        new := Concatenation(new, ins[ext[k]]);
        AddSet(out, B);
        bt(B, new);
      fi;
    od;
  end;

  AddSet(out, ideal);
  bt(ideal, next);
  return out;
end;

###############################################################################
# Conjugating elements
###############################################################################

SEMIGROUPS.ConjugateGroupHClassElementsInDClass := function(X, list)
  local out, x;
  out := [];
  for x in list do
    Append(out, SEMIGROUPS.ConjugateGroupHClassElementInDClass(X, x));
  od;
  return out;
end;

SEMIGROUPS.ConjugateGroupHClassElementInDClass := function(X, x)
  local reps;
  reps := HClassReps(RClass(X, x));
  return List(reps, rep -> rep ^ -1 * x * rep);
end;

################################################################################
## Examples
################################################################################
#
#gap> S := InverseMonoid( [
#> PartialPerm( [ 1, 2, 3, 4, 5, 6, 7, 8 ], [ 2, 3, 4, 1, 6, 7, 8, 5 ] ),
#> PartialPerm( [ 1, 2, 3, 4, 5, 6, 7, 8 ], [ 2, 1, 3, 4, 6, 5, 7, 8 ] ),
#> PartialPerm( [ 2, 3, 4, 5, 6, 7, 8 ], [ 1, 2, 3, 8, 5, 6, 7 ] ),
#> PartialPerm( [ 1, 2, 3, 5, 6, 7, 8 ], [ 2, 3, 4, 6, 7, 8, 5 ] ) ] );;
#gap> N := SEMIGROUPS.KernelMaxIdempotentSeparatingCongruence(S);;
#gap> Idempotents(N) = Idempotents(S);
#true
#gap> cong := InverseSemigroupIdempotentSeparatingCongruence(S, N);;
#gap> IsIdempotentSeparatingCongruence(cong);
#true
#gap> Q := S/cong;;
#gap> NrLClasses(Q) = NrLClasses(S);
#true
#gap> NrRClasses(Q) = NrRClasses(S);
#true
#gap> NrDClasses(Q) = NrDClasses(S);
#true
#gap> NrHClasses(Q) = NrHClasses(S);
#true
#
#gap> s := PartialPerm( [ 5, 6, 7, 8 ], [ 5, 7, 6, 8 ] );;
#gap> t := PartialPerm( [ 5, 6, 7, 8 ], [ 5, 6, 7, 8 ] );;
#gap> K1 := SEMIGROUPS.KerIdSepCongByGeneratingPair(S, [s, t]);;
#gap> IsSubset(N, K1);
#true
#gap> cong := InverseSemigroupIdempotentSeparatingCongruence(S, K1);;
#gap> IsIdempotentSeparatingCongruence(cong);
#true
#gap> Q := S/cong;;
#gap> NrLClasses(Q) = NrLClasses(S);
#true
#gap> NrRClasses(Q) = NrRClasses(S);
#true
#gap> NrDClasses(Q) = NrDClasses(S);
#true
#gap> NrHClasses(Q) = NrHClasses(S);
#true
#
#gap> s := PartialPerm( [ 4, 5, 6, 7, 8 ], [ 4, 6, 7, 5, 8 ] );;
#gap> t := PartialPerm( [ 4, 5, 6, 7, 8 ], [ 4, 5, 6, 7, 8 ] );;
#gap> K2 := SEMIGROUPS.KerIdSepCongByGeneratingPair (S, [s, t]);;
#gap> IsSubset(N, K2);
#true
#gap> cong := InverseSemigroupIdempotentSeparatingCongruence(S, K2);;
#gap> IsIdempotentSeparatingCongruence(cong);
#true
#gap> Q := S/cong;;
#gap> NrLClasses(Q) = NrLClasses(S);
#true
#gap> NrRClasses(Q) = NrRClasses(S);
#true
#gap> NrDClasses(Q) = NrDClasses(S);
#true
#gap> NrHClasses(Q) = NrHClasses(S);
#true
